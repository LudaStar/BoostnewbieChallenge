1. malloc과 포인터 복습

포인터를 선언하고 나서 메모리를 할당해주어야 함

int *x;
x = malloc(sizeof(int));


2. 배열의 크기 조정하기 (list.c, realloc.c)

일정한 크기의 배열이 주어졌을 때 그 배열의 크기를 키우려면 새로운 공간에 메모리를 다시 할당하고
기존 배열의 값들을 하나씩 옮겨줘야 함
이런 작업은 O(n), 즉 배열의 크기 n만큼의 실행 시간이 소요될 것

for문을 이용하거나 realloc함수 사용


3. 연결 리스트 : 도입

연결 리스트 - 저장된 값들이 연속된 주소값을 가지지 않고 인덱스를 사용할 수 없음
각 메모리 덩어리에 변수값과 다음 변수값의 주소가 들어있음 가장 마지막엔 변수값과 널값이 들어있음(리스트의 끝임을 알림)

배열 - 고정된 메모리 덩어리(주소가 연속됨)
각 인덱스 값이 메모리상에서 연이어 저장되어 있음

typedef struct node //node라는 구조체는 number과 *next 두 개의 필드가 함께 정의되어 있음
// typedef struct 대신에 typedef struct node라고 'node'를 명시해 주는 것은 구조체 안에서 node를 사용하기 위함
{
    int number; // 각 node가 가지는 값
    struct node *next; // 다음 node를 가리키는 포인터
}
node; //struct의 닉네임


4. 연결 리스트 : 코딩(node.c)

node *n = malloc(sizeof(node)); //node를 저장할 만큼 메모리 덩어리를 할당해줌
(*n).number = 2; // n에 있는 주소에 해당하는 메모리 덩어리로 가서 number필드에 접근

node *n = malloc(sizeof(node));
if( n != NULL)
{
    n->number = 2; // (*n).number = 2; 와 같은 의미
    n->next = NULL;
}


5. 연결 리스트 : 시연(node.c)

배열과 비교해서 연결 리스트는 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다는 장점이 있음
하지만 연결 리스트에는 임의 접근이 불가능한 것이 단점

연결 리스트에서 값을 추가하거나 검색하는 경우에 해당하는 위치까지 연결 리스트의 각 node를 따라 이동
따라서 연결 리스트의 크기가 n일 때 실행시간은 O(n)

배열의 경우 임의 접근이 가능하기 때문에 이진 검색을 이용하면 O(log n)의 실행 시간 소요


6. 연결 리스트 : 트리 (tree.c)

Search, Insert - O(log n)

가장 높은 층에서 시작되는 노드를 '루트', 그 다음 층의 노드들은 '자식 노드'


7. 해시 테이블

Serach - O(n) (최악의 경우), O(1) (바구니를 최대한 많이 만드는 경우)

해시 테이블은 연결 리스트의 배열이고 각 값들은 해쉬 함수라는 맞춤형 함수를 통해 어떤 바구니에 담기는지가 결정
각 바구니에 담기는 값들은 그 바구니에서 정의된 연결리스트로 이어짐


8. 트라이

많은 메모리가 들지만 자료 구조 안에 있는 이름이나 단어를 찾는데 일정한 실행 시간을 가짐

각각의 노드가 배열로 이루어진 트리

값을 검색하는 실행 시간은 Harry는 5단게, Hermionie는 8단계, 즉 문자열의 길이임
가장 긴 이름의 길이가 실행시간이 됨(상수) -> O(1)

그러나 실행시간이 짧은 만큼 많은 양의 메모리가 필요함

9. 스택, 큐, 딕셔너리

큐 - 선입선출(FIFO), enqueue, dequeue, 배열이나 연결 리스트를 통해 구현 가능

스택 - 후입선출(LIFO), Push, Pop, 배열이나 연결 리스트를 통해 구현 가능

딕셔너리 - 키와 값이라는 요소로 이루어짐, 해시 테이블과 동일한 개념
